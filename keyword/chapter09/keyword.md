## 1. Spring Data JPA의 Paging

### Paging이란?

사용자가 어떠한 데이터를 요청했을 때, 전체 데이터 중 일부를 원하는 정렬 방식으로 보여주는 방식이다.<br>

### Paging 기법 구현

- page : paging 기법이 적용되었을 때, 원하는 페이지.
- size : 해당 페이지에 담을 데이터 개수.
- sort : 정렬 기준.
<br>

이 파라미터들을 Pageable 구현체에 담아 paging을 설정한다.<br>
Spring Data JPA는 paging을 위해 두 가지 객체를 제공한다.

### 1) Page

**조회쿼리 이후에 전체 데이터 개수를 한번 더 조회하는 카운트 쿼리가 실행**된다.

- page 인터페이스는 slice 인터페이스를 상속받는다.
- 전체 페이지 개수나 데이터 개수가 필요한 경우에 유용하다.
- 총 데이터 개수를 계산하기에, 데이터셋이 클 경우 카운트 쿼리가 성능에 영향을 미칠 수 있다. 즉, slice에 비해 느릴 수 있다.


### 2) Slice

**카운트쿼리가 나가지 않고 다음 slice가 존재하는지 여부만을 확인**할 수 있다.

- 데이터의 양이 많으면 많을수록 slice가 성능상 유리하다.
- ex) 무한스크롤 : 스크롤 바가 아래 끝에 다다르면 추가 데이터를 요청하는 기능.

<br>
<br>

## 2. 객체 그래프 탐색

참조를 사용해서 연관관계를 탐색하는 것을 말한다.<br>
즉, 객체 A가 있을 때 A가 참조하는 다른 객체 B, C, D등을 A를 통해 참조하는 것이다.

연관된 데이터 조회 시, JPA는 **즉시 로딩**과 **지연 로딩**을 지원한다.

- 즉시 로딩 (Eager Loading) : 엔티티를 조회할 때 연관된 엔티티도 함께 조회.
- 지연 로딩 (Lazy Loading) : 연관된 엔티티를 실제 사용할 때 조회.

### JPA 기본 fetch 전략

연관된 엔티티가 하나면 즉시 로딩을, 컬렉션이면 지연 로딩을 사용한다.<br>
컬렉션을 로딩하는 것은 비용이 많이 들고 잘못하면 너무 많은 데이터를 로딩할 수 있기 때문.

### 객체 그래프 탐색의 주의점

1. 순환 의존성 - 리팩토링으로 의존성 분리, @Lazy 주입으로 지연 초기화로 해결.

2. 복잡성 증가 - 계층화된 설계, 모듈화를 통해 객체 그래프 단순화로 해결.

3. N+1 문제

### N+1 문제란?

특정 엔티티를 조회할 때 관련된 연관 엔티티를 탐색하면서 추가적인 쿼리가 예상보다 훨씬 많이 실행되는 상황.<br>
즉, 엔티티가 N개일 때 총 N+1개의 쿼리가 실행되는 것.

### N+1 문제 해결 방법

**1. Fetch Join**

JPQL에서 fetch join을 사용해 부모 엔티티와 연관된 자식 엔티티를 한 번에 가져온다.

**2. @EntityGraph**

JPA의 @EntityGraph를 사용해서 특정 연관 관계를 즉시 로딩으로 변경한다.

**3. @BatchSize**

연관 엔티티를 한 번에 로드하여 쿼리 호출 횟수를 줄인다.

**4. DTO로 직접 조회**

엔티티가 아닌 필요한 데이터만 담는 DTO를 사용해 직접 조회한다.